# Руководство Rust #

## 2 Hello, World! ##
Теперь, когда вы установили Rust, напишем первую вашу программу на Rust. Это традиция, в любом новом языке программирования, делать первую программу такой, которая выводит текст "Hello, World!" на экран. Хорошая штука начинать с такой простой программы в том, что вы можете убедиться что ваш компилятор не только установлен, но и работает правильно. И вывод информации на экран является довольно обычным способом для этого.

Первое с чего мы должны начать это создать файл для нашего кода. Мне нравится размещать каталог `projects` в домашнем каталоге, и хранить все мои проекты там. Для Rust неважно где располагается ваш код.

Это на самом деле приводит к еще одной проблеме о которой мы должны предупредить: это руководство предполагает, что у вас есть базовые навыки работы в командной строке. Rust не требует от вас великих познаний о командной строке, но до тех пор пока язык не будет в более завершенном виде, поддержка IDE затруднительна. У Rust нет специфичных требований к вашей среде разработки или к тому где вы храните свой код.

С учетом сказанного, давайте сделаем каталог в нашем каталоге с проектами.

    $ mkdir ~/projects
    $ cd ~/projects
    $ mkdir hello_world
    $ cd hello_world

Если вы используете Windows и не используете PowerShell, `~` может не работать. Обратитесь к документации вашей оболочки для уточнения деталей.

Теперь создадим новый файл для текста программы. Я собираюсь использовать синтаксис `editor filename` для обозначения редактируемого файла в этих примерах, но вам следует использовать любой метод, который хотите. Назовем наш файл `main.rs`:

`$ editor main.rs`

Rust файлы всегда заканчиваются расширением `.rs`. Если вы используете больше одного слова в имени вашего файла используйте подчеркивание. `hello_world.rs` лучше чем `helloworld.rs`.

Теперь когда файл открыт, запишите в него:

    fn main() {
        println!("Hello, world!");
    }

Сохраните файл и затем введите в вашем окне терминала:

    $ rustc main.rs
    $ ./main # или main.exe в Windows
    Hello, world!

Успех! Разберем что же случилось подробнее.

    fn main() {

    }

Эти строки определяют **функцию** в Rust'е. Функция `main` специальна: это начало каждой программы на Rust. Первая строка говорит "Я объявляю функцию именуемую `main`, которая не получает параметров и ничего не возвращает". Если бы были параметры, они бы шли в скобках (`(` и `)`), и потому что мы ничего не возвращаем из этой функции, мы опустим эту запись полностью. Мы вернемся к этому позже.

Вы должны были заметить, что функция обернута в фигурные скобки (`{` и `}`). Rust требует их вокруг всех тел функций. Так же хорошим стилем считается ставить открывающую фигурную скобку на той же строке, что и объявление функции, отделенную одним пробелом.

Теперь эта строка:

	println!("Hello, world!");

Эта строка делает всю работу в нашей маленькой программе. Тут есть несколько деталей, которые имеют существенное значение. Во-первых, отступ в четыре пробела, а не табуляция. Пожалуйста, настройте выбранный вами редактор так, чтобы вставлять четыре пробела при помощи клавиши табуляции. Мы предоставляем некоторые [примеры настроек для различных редакторов](https://github.com/rust-lang/rust/tree/master/src/etc "Примеры настроек для различных редакторов").

Во-вторых, это часть с `println!()`. Это вызов макроса Rust, которым представлено метапрограммирование в Rust'e. Если бы вместо этого была функция, это бы выглядело следующим образом: `println()`. Для достижения нашей цели, нас не должна волновать эта разница. Просто знайте, что иногда вы будете видеть `!`, и это означает, что вы вызываете макрос вместо нормальной функции. Rust реализует `println!` как макрос вместо функции по веским причинам, но это очень углубленная тема. Вы узнаете больше, когда мы будем позже рассказывать о макросах. И последнее, что нужно отметить: макросы Rust'a значительно отличаются от макросов на C, если вы их использовали. Не бойтесь использовать макросы. В конце концов мы вернемся к деталям, а сейчас просто доверьтесь нам.

Дальше, `"Hello, world!"` это **строка**. Строки удивительно сложная тема в системном языке программирования и это statically allocated строка. Мы расскажем больше о различных видах распределения памяти позже. Передадим эту строку в качестве аргумента в `println!`, который выводит строки на экран. Это достаточно просто!

В завершение, строка заканчивается точкой с запятой(`;`). Rust `выражение-ориентированный` язык, что означает, что в нем большая часть вещей является выражением. `;` используется для указания, что это выражение заканчивается, а следующее начинается. Большинство строк кода на Rust заканчивается `;`. Мы рассмотрим это позже в отдельном разделе руководства.

На самом деле, завершением будет сборка и запуск нашей программы. Соберем нашим компилятором `rustc`, передав ему в качестве аргумента название нашего файла с кодом:

    $ rustc main.rs

Это похоже на `gcc` или `clang`, если вы программировали раньше на C или C++. Rust выдаст двоичный исполняемый файл. Вы можете убедиться в этом с помощью `ls`:

    $ ls
    main main.rs

Или в Windows:

    $ dir
    main.exe main.rs

Это два файла: наш исходный код, с расширением `.rs` и исполняемый файл (`main.exe` в Windows, `main` в остальных случаях)

    $ ./main  # или main.exe в Windows

Это выведет наш "Hello, world!" текст в наш терминал.

Если вы перешли из динамически-типизированных языков программирования вроде Ruby, Python или JavaScript, вы не можете использовать эти два шага отдельно. Rust **компилируемый перед исполнением** язык, это означает, что вы можете собрать программу, дать ее кому-то еще, и ему не нужно устанавливать Rust. Если вы передадите один из `.rb` или `.py` или `.js` файл, ему нужно будет установить Ruby/Python/JavaScript, но запустить только одну команду для каждого из них, что бы скомпилировать и запустить вашу программу. Все это взаимоисключаемо в дизайне языков программирования, и Rust сделал свой выбор.

Поздравляем! Вы официально написали программу на Rust. Это делает вас Rust-программистом! Добро пожаловать.


## 3 Hello, Cargo! ##
[Cargo](http://doc.crates.io "Cargo site") это инструмент который Ржавообразные используют для управления своими Rust проектами. Cargo сейчас в состоянии альфы, как и Rust, и работа над ним еще продолжается. Тем не менее, он уже достаточно хорош для использования во многих Rust проектах, и поэтому предполагается, что проекты на Rust будут использовать Cargo с самого начала.

Cargo управляет тремя вещами: собирает ваш код, скачивает нужные вашему коду зависимости и собирает их. По-началу, вашей программе не понадобятся никаких зависимостей, поэтому будем использовать только первую часть его функционала. В конце концов нам понадобится добавить несколько зависимостей. Поскольку мы начали с использованием Cargo, не составит труда добавить их позже.

Преобразуем наш Hello World в Cargo. Первая вещь, которую мы должны сделать для того, что бы начать использовать Cargo - это установить его. К счастью для нас, скрипт который мы запускали для установки Rust по умолчанию включает в себя установку Cargo. Если вы установили Rust каким-либо другим способом, вы должны проверить [Cargo README для специальных инструкций по установке](https://github.com/rust-lang/cargo#installing-cargo-from-nightlies "Инструкция по установке Cargo").

Чтобы Cargo-фицировать ваш проект, вы должны сделать две вещи: создать `Cargo.toml` конфигурационный файл, и поместить файл с исходным кодом в правильное место. Давайте сделаем эту часть первой:

    $ mkdir src
    $ mv main.rs src/main.rs

Cargo ожидает что ваши файлы с исходным кодом находятся в директории `src`. Это оставляет верхний уровень для других вещей, вроде README, файлов с текстом лицензии и других не относящихся к вашему коду. Cargo помогает нам сохранять наши проекты красивыми и аккуратными. Всему своё место и всё на своём месте.

Дальше, наш конфигурационный файл:

    $ editor Cargo.toml

Убедитесь, что имя правильное: вам нужна заглавная `C`!

Разместите это внутри:

    [package]

    name = "hello_world"
    version = "0.0.1"
    authors = [ "Ваше имя <you@example.com>" ]

    [[bin]]

    name = "hello_world"

Этот файл в формате [TOML](https://github.com/toml-lang/toml "Описание формата TOML"). Позволим ему самому объясниться с вами:
>TOML стремится быть минимальным форматом для конфигурационных файлов, который легко читается благодаря понятной семантике. TOML спроектирован для однозначного отображения в хэш-таблицу. TOML должен легко преобразовываться в структуры данных широкого спектра языков программирования.

TOML очень похож на INI, но с некоторыми дополнительными возможностями.

В любом случае, в этом файле есть две записи: `package` и `bin`. Первая сообщает Cargo метаданные вашего пакета. Вторая сообщает Cargo что мы заинтересованы в сборке исполняемого файла, а не библиотеки (хотя мы могли сделать и то и другое!), и как его следует назвать.

Как только мы с этим закончили, мы готовы к сборке! Попробуйте собрать:

    $ cargo build
        Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)
    $ ./target/hello_world
    Hello, world!

Та-да! Мы собрали наш проект вызвав `cargo build`, и запустили его с помощью `./target/hello_world`. Нас этим не купить по сравнению с более простым использованием `rustc`, но подумаем о будущем: если бы в нашем проекте было больше одного файла мы бы должны были вызвать `rustc` для каждого и передать ему кучу параметров, что бы собрать их все вместе. С `Cargo` когда наш проект вырастет нам понадобится вызвать только команду `cargo build` и она должна будет работать правильно.

Так же вы должны были заметить что Cargo создал новый файл: `Cargo.lock`.

    [root]
    name = "hello_world"
    version = "0.0.1"

Этот файл используется Cargo для отслеживания зависимостей в вашем приложении. Прямо сейчас у нас нет ни одной, поэтому этот файл довольно пуст. Вам не нужно править этот файл самостоятельно, Cargo сам с ним разберется.

Так! Мы успешно собрали `hello_world` с помощью Cargo. Несмотря на то, что наша программа проста, мы использовали большую часть реальных инструментов, которые вы будете использовать в своем дальнейшем пути Rust программиста.

Теперь давайте отложим инструментарий и узнаем больше о самом языке Rust. Эти основы сослужат вам хорошую службу до конца вашего времени с Rust.

## 4 Связывание переменных ##
Первая вещь которую мы должны знать о "связывании переменных" - это выглядит примерно так:

    let x = 5i;

Во многих языках программирования это называется "переменная". Но связывание переменных Rust'а имеет пару трюков в рукаве. Rust имеет мощную особенность называемую 'шаблоном', который мы рассмотрим позже более детально, с левой стороны выражение `let` это полный шаблон, а не просто имя переменной. Это значит что мы можем делать вещи вроде этой:

    let (x, y) = (1i, 2i);

После завершения этого выражения `x` будет единицей, a `y` двойкой. Шаблоны правда мощны, но пока это все, что мы можем с ними сделать. Так что придержите это в уме, продвигаясь дальше.

В этом примере, кстати, `i` показывает что число является целым числом.

Rust статически типизированный язык программирования, что означает, что мы сперва мы должны указать наш тип. Так почему же наш первый пример скомпилировался? В Rust'е есть такая вещь, как "вывод типа". Если Rust может понять какой тип у чего-либо, то он не требует указывать его.

Тем не менее, мы можем указать желаемый тип. Он следует после двоеточия (`:`):

    let x: int = 5;

Если бы я попросил вас прочитать это вслух и по-порядку, вы бы сказали "`x` связан с типом `int` и значением `пять`"

По-умолчанию, связывание `неизменяемо`. Этот код не скомпилируется:

    let x = 5i;
    x = 10i;

Мы получим эту ошибку:

    error: re-assignment of immutable variable `x`
        x = 10i;
        ^~~~~~~

Если вы хотите что бы связывание было изменяемым, вы можете использовать `mut`:

    let mut x = 5i;
    x = 10i;

Может показаться, что нет ни одной причины делать связывание неизменяемым по-умолчанию, но вспомните, на чем в первую очередь сфокусирован Rust: на безопасности. Если вы случайно забыли указать `mut`, компилятор поймет это, и вы узнаете, что изменили то, что возможно не собирались менять. Если бы связывание по-умолчанию было бы изменяемым, в такой ситуации компилятор не смог бы вам помочь.






